IMPORTANT

Make sure to update this file to include your NAME and PID so we can
associate your GitHub repo with your class enrollment.

All input.* and communicate.* files will be overwritten when we grade Lab 1.
Please refer to the website under the projects section for further instructions.
http://cseweb.ucsd.edu/classes/fa17/cse123-a/project.html

Name: Renxu Hu
PID: A92067683
File: README
All the high level description is writing here, please check

Clarification and Description of the Program
First of all, my program runs a little bit slower, and the reason for that is
I was using a relative different approach. However, the main approach is the 
same because I am using selective retransmission. However, instead of using 
the timeout as the main tool for retransmission, I am processing the linked 
list in the handle incoming acks. So for instance, if the message conrrupted,
then I handle the case to check what ack number has returned. I will usually
send back ack number + 1 frame to the receiver. For instance, if sender sends
frame 1, receiver sends back ack 1; later sender sends frame 2~4, receiver 
sends back ack 2 since 3 is lost. So the sender sends back frame 3. I am 
using the timeout only when the ack is corrupted. The reason why it is slower
since I am heavily run on memory, and also the linked list is heavier to 
manipulate. 
If I am having corrupted incoming ack, my timeout will figure out and then 
send back the frame, if received before, the receiver will ignore it.

Frame:
My frame is in total 64 bytes, with 7 bytes encapsulated header, and 57 bytes 
data.
It has source id, destination id, seqence number and ack number, sameMsg means
whether the data is in the same message as previous. If it is, then it will be
1, if it is not, then it is 0. There is one byte (char) which is used to check
the corruption of the frame. First six bytes are all uint8_t type which will be
automatically wrapped around at 255.
